---
   layout: default
　　title: 闭包
---

## 闭包
一、闭包的定义：

闭包（closure）是一个函数在创建时允许该自身函数访问并操作该自身函数之外的变量时所创建的作用域， 话句话说，闭包可以让函数访问所有的变量和函数，只要这些变量和函数存在于该函数声明的作用域内就行；
声明的函数在后续什么时候都可以被调用，即使是声明时的作用域消失之后 ------《javaScript Ninja》

如果一个函数访问了它的外部变量，那么它就是一个闭包。**从技术上来讲，在JS中，每个function都是闭包，因为它总是能访问在它外部定义的数据。**

**闭包是指有权访问另外一个函数作用域中的变量的函数。创建闭包的常见方式就是在一个函数内部创建另外一个函数。**

**简单来说，closure是一块域，这块域是由创建一个function而来，这个function可以访问和操作它的外部的变量**

二、闭包的使用：

1.私有变量
变量的一种常见用法是封装一些信息作为“私有变量”，也就是限制这些变量的作用域
<pre><code>
function Ninja() {
    var feints = 0;
    this.getFeints = function(){
        return feints;
    }; 
    this.feint = function(){
        feints++;
    };
}

var ninja = new Ninja();
ninja.feint();
console.log(ninja.getFeints());     // 1
console.log(ninja.feints);      //undefined
</code></pre>
**变量feints在外部无法访问，可以看做私有变量**

这里没有直接对变量赋值，而是通过方法feint，将变量feints变成了1；之所以可以操作feints的值，是因为即使构造函数执行完并且已经没有作用域了，feints变量还是会存在feint()方法声明创建的闭包上

2.回调（callback）与 计时器（timer）

另一个使用闭包的最常见情形，是在处理回调或使用计时器的时候。

<pre><code>
jQuery('#testButton').click(function(){  
    var elem$ = jQuery("div");  
    elem$.heml("Loading...");  
    jQuery.ajax({  
        url: test.html,  
        success: function(html){ 
        //assert方法：可以认为if第一个参数的结果是true,输出第二个参数 
            assert(elem$,  
                "We can see elem$, via the closure for this callback.");  
            elem$.html(html);  
        }  
    });  
});  
</code></pre>

在传递给jQuery ajax()方法的参数中，我们定义了一个匿名函数作为成功后的回调，在这个回调中，我们通过闭包引用了elem$变量

<pre><code> 
function animateIt(){
    var tick = 0;  
    var timer = setInterval(function(){  
        if (tick < 100){ 
            tick++;  
        }else{  
            clearInterval(timer);  
            assert(tick == 100,   
                "Tick accessed via a closure."); 
            assert(timer,  
                "Timer reference also obtained via a closure.")  
        }  
    }, 10);
}
animateIt();
</code></pre>

定义了一个匿名函数作为参数传递给setInterval函数，这里通过闭包引用并改变了tick变量

3.函数重载
js可以根据传入参数的个数实现函数的重载，一般通常的方法：
<pre><code>
var ninja = {
    whatever: function(){
        switch(arguments.length){
            case 0:
                ...
                break;
            case 1:
                ...
                break;
            ....
        }
    }
}；
</code></pre>
这里可以通过闭包实现函数重载，减少判断分支
<pre><code> 
function addMethod(object, name, fn){
    var old = object[name];
    object[name] = function(){
        if(fn.length == arguments.length)
            return fn.apply(this, arguments);
        else if (typeof old == 'function')
            return old.apply(this, arguments);
    }
}

var ninja = {};
addMethod(ninja, 'whatever', function(){console.log('0 arguments')});
addMethod(ninja, 'whatever', function(a){console.log('1 arguments', a)});
addMethod(ninja, 'whatever', function(a,b){console.log('2 arguments', a, b)});

//调用
ninja.whatever();    //0 arguments
ninja.whatever(2);   //1 arguments 2
ninja.whatever(2,3); //2 arguments 2 3
</code></pre>
*通过addMethod方法，给object绑定方法， 函数的length属性是函数声明时的命名参数个数。eg: function(a,b,c,d){} 这个函数的length 就是4*

每次调用addMethod方法时，都定义了一个匿名函数，创建了一个闭包，这个闭包中的old变量保存了上次调用addMethod时的object[name], 这里调用了三次addMethod, 创建了三个闭包，没个闭包中的old变量和object[name]都是独立的，互相不影响的。

(1) 第一次调用时， ninja[whatever]不存在，所以这是old的值是undefined；接下来创建了匿名函数并赋值给 ninja[whatever]，此时object[name] 方法中old 是 undefined,  fn 是 function(){console.log('0 arguments')}

(2)  第二次调用时，将上次object[name]赋值给old，此时old方法中中fn 是 function(){console.log('0 arguments')}
接下来重新创建匿名函数赋值给object[name]， 此时object[name]中的fn变成了function(a){console.log('1 arguments', a)}

(3) 第三次调用同上，此时old方法中中fn 是function(a){console.log('1 arguments', a)}， object[name]中的fn变成了function(a,b){console.log('2 arguments', a, b)}
每次调用的时候，通过判断参数的长度，决定执行object[name]，还是old；
这里可以看做是递归，如果传入0个参数，先执行两个参数的whatever，传入参数与声明不符，调用old， 递推到一个参数的whatever，若还不符合，再递推到0个参数的whaterver

**这里需要理解的是，每次调用addMethod，都通过匿名函数创建了闭包，闭包中保持了当前的作用域，和当前的old变量**， 这也是whatever函数可以从两个参数一直递推到0个参数的原因

___
