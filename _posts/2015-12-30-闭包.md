---
   layout: default
　　title: 闭包
---

## 闭包
一、闭包的定义：

闭包（closure）是一个函数在创建时允许该自身函数访问并操作该自身函数之外的变量时所创建的作用域， 话句话说，闭包可以让函数访问所有的变量和函数，只要这些变量和函数存在于该函数声明的作用域内就行；
声明的函数在后续什么时候都可以被调用，即使是声明时的作用域消失之后 ------《javaScript Ninja》

如果一个函数访问了它的外部变量，那么它就是一个闭包。**从技术上来讲，在JS中，每个function都是闭包，因为它总是能访问在它外部定义的数据。**

**闭包是指有权访问另外一个函数作用域中的变量的函数。创建闭包的常见方式就是在一个函数内部创建另外一个函数。**

**简单来说，closure是一块域，这块域是由创建一个function而来，这个function可以访问和操作它的外部的变量**

二、闭包的使用：

1.私有变量
变量的一种常见用法是封装一些信息作为“私有变量”，也就是限制这些变量的作用域

```javascript
function Ninja() {
    var feints = 0;
    this.getFeints = function(){
        return feints;
    }; 
    this.feint = function(){
        feints++;
    };
}

var ninja = new Ninja();
ninja.feint();
console.log(ninja.getFeints());     // 1
console.log(ninja.feints);      //undefined
```
**变量feints在外部无法访问，可以看做私有变量**

这里没有直接对变量赋值，而是通过方法feint，将变量feints变成了1；之所以可以操作feints的值，是因为即使构造函数执行完并且已经没有作用域了，feints变量还是会存在feint()方法声明创建的闭包上

2.回调（callback）与 计时器（timer）

另一个使用闭包的最常见情形，是在处理回调或使用计时器的时候。

```javascript
jQuery('#testButton').click(function(){  
    var elem$ = jQuery("div");  
    elem$.heml("Loading...");  
    jQuery.ajax({  
        url: test.html,  
        success: function(html){ 
        //assert方法：可以认为if第一个参数的结果是true,输出第二个参数 
            assert(elem$,  
                "We can see elem$, via the closure for this callback.");  
            elem$.html(html);  
        }  
    });  
});  
```

在传递给jQuery ajax()方法的参数中，我们定义了一个匿名函数作为成功后的回调，在这个回调中，我们通过闭包引用了elem$变量

```javascript  
function animateIt(){
    var tick = 0;  
    var timer = setInterval(function(){  
        if (tick < 100){ 
            tick++;  
        }else{  
            clearInterval(timer);  
            assert(tick == 100,   
                "Tick accessed via a closure."); 
            assert(timer,  
                "Timer reference also obtained via a closure.")  
        }  
    }, 10);
}
animateIt();
```

定义了一个匿名函数作为参数传递给setInterval函数，这里通过闭包引用并改变了tick变量

