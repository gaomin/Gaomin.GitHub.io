---
   layout: default
　　title: 前端跨域
---
## 跨域

在多个项目组共存的公司，基本上都会遇到跨域的问题，之前在小公司，项目相对独立，基本上没有接触过跨域的问题，现在的日常工作中常常会涉及到跨域的问题，但是仍然不甚了解，因而自认为应该专门学习下。

### 1、跨域问题产生的原因
跨域问题是因为浏览器的同源策略导致的，可以认为是浏览器的一种安全限制。

### 2、浏览器的同源策略

| URL           | 说明           | 是否允许通信  |
| ------------- |:-------------:| -----|
| http://www.a.com/a.js<br/>http://www.a.com/b.js | 同一域名下 | 允许 |
| http://www.a.com/lab/a.js<br/>http://www.a.com/script/b.js | 同一域名下不同文件夹 | 允许 |
| http://www.a.com:8000/a.js<br/>http://www.a.com/b.js | 同一域名，不同端口 | 不允许 |
| http://www.a.com/a.js<br/>https://www.a.com/b.js  |  同一域名，不同协议 | 不允许 |
| http://www.a.com/a.js<br/>http://70.32.92.74/b.js | 域名和域名对应ip | 不允许 |
| http://www.a.com/a.js<br/>http://script.a.com/b.js | 主域相同，子域不同 | 不允许 |
| http://www.a.com/a.js<br/>http://a.com/b.js | 同一域名，不同二级域名（同上）| 不允许 |
| http://www.cnblogs.com/a.js<br/>http://www.a.com/b.js | 不同域名 | 不允许 |

<br/>**这里有两点注意：**

1) 如果是协议和端口造成的跨域问题，前端是无能为力的

2) 在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。

*“URL的首部”指window.location.protocol + window.location.host，也可以理解为“Domains, protocols and ports must match”。*

### 3、跨域方式

**1、jsonp**

JSONP包含两部分：回调函数和数据。回调函数是当响应到来时要放在当前页面被调用的函数。数据就是传入回调函数中的json数据，也就是回调函数的参数了。

原理是**\<script>标签的src属性是没有跨域的限制的**

<pre><code class="JavaScript">
    function handleResponse(response){
        console.log('The responsed data is: '+response.data);
    }
    var script = document.createElement('script');
    script.src = 'http://www.baidu.com/json/?callback=handleResponse';
    document.body.insertBefore(script, document.body.firstChild);

    /*handleResonse({"data": "zhe"})*/
    //原理如下：
    //当我们通过script标签请求时
    //后台就会根据相应的参数(json,handleResponse)
    //来生成相应的json数据(handleResponse({"data": "zhe"}))
    //最后这个返回的json数据(代码)就会被放在当前js文件中被执行
    //至此跨域通信完成
</code></pre>

此外，比较常用的方式是将 jQuery.ajax 的 dataType 设置为 'jsonp' 实现。

*如果设为dataType: 'jsonp'，这个$.ajax方法就和ajax XmlHttpRequest没什么关系了，取而代之的则是JSONP协议。JSONP是一个非官方的协议，它允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问。*

jsonp虽然很简单，但是有如下缺点：

1）安全问题(请求代码中可能存在安全隐患)

2）要确定jsonp请求是否失败并不容易

**2、CORS(相比jsonp,更推荐)**

跨域资源共享（CORS）

Cross-Origin Resource Sharing (CORS) 是W3c工作草案，它定义了在跨域访问资源时浏览器和服务器之间如何通信。CORS背后的基本思想是使用自定义的HTTP头部允许浏览器和服务器相互了解对方，从而决定请求或响应成功与否。

**服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。**
Header set Access-Control-Allow-Origin * 
为了防止XSS攻击我们的服务器， 我们可以限制域，比如
Access-Control-Allow-Origin: http://a.com

[CORS 跨域 实现思路及相关解决方案](http://www.cnblogs.com/sloong/p/cors.html)

**3、document.domain+iframe的设置**

对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决。

具体的做法是可以在http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上document.domain = ‘a.com’；然后通过a.html文件中创建一个iframe，去控制iframe的contentDocument，这样两个js文件之间就可以“交互”了。*当然这种办法只能解决主域相同而二级域名不同的情况，如果你异想天开的把script.a.com的domian设为alibaba.com那显然是会报错地！*

<pre><code class="JavaScript">
/*http://www.a.com/a.html*/
    document.domain = 'a.com';
    var ifr = document.createElement('iframe');
    ifr.src = 'http://script.a.com/b.html';
    ifr.style.display = 'none';
    document.body.appendChild(ifr);
    ifr.onload = function(){
        var doc = ifr.contentDocument || ifr.contentWindow.document;
        // 在这里操纵b.html
        alert(doc.getElementsByTagName("h1")[0].childNodes[0].nodeValue);
    };

/*http://script.a.com/b.html*/
    document.domain = 'a.com';
</code></pre>

**页面的domain默认等于window.location.hostname。主域名是不带www的域名，例如a.com，主域名前面带前缀的通常都为二级域名或多级域名，例如www.a.com其实是二级域名。domain只能设置为主域名，不可以在b.a.com中将domain设置为c.a.com。**

问题：

1）安全性，当一个站点（b.a.com）被攻击后，另一个站点（c.a.com）会引起安全漏洞。

2）如果一个页面中引入多个iframe，要想能够操作所有iframe，必须都得设置相同domain。

**4、利用iframe和location.hash**

原理是利用location.hash来进行传值。在url： http://a.com#helloword中的‘#helloworld’就是location.hash，改变hash并不会导致页面刷新，所以可以利用hash值来进行数据传递，当然数据容量是有限的。

假设域名a.com下的文件cs1.html要和cnblogs.com域名下的cs2.html传递信息，cs1.html首先创建自动创建一个隐藏的iframe，iframe的src指向cnblogs.com域名下的cs2.html页面，这时的hash值可以做参数传递用。cs2.html响应请求后再将通过修改cs1.html的hash值来传递数据（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于a.com域名下的一个代理iframe；Firefox可以修改）。同时在cs1.html上加一个定时器，隔一段时间来判断location.hash的值有没有变化，一点有变化则获取获取hash值。

<pre><code class="JavaScript">
/*http://a.com/cs1.html*/
    function startRequest(){
        var ifr = document.createElement('iframe');
        ifr.style.display = 'none';
        ifr.src = 'http://www.cnblogs.com/cs2.html#paramdo';
        document.body.appendChild(ifr);
    }

    function checkHash() {
        try {
            var data = location.hash ? location.hash.substring(1) : '';
            if (console.log) {
                console.log('Now the data is '+data);
            }
        } catch(e) {};
    }
    setInterval(checkHash, 2000);

/*http://www.cnblogs.com/cs2.html*/
    //模拟一个简单的参数处理操作
    switch(location.hash){
        case '#paramdo':
            callBack();
            break;
        case '#paramset':
            //do something……
            break;
    }

    function callBack(){
        try {
            parent.location.hash = 'somedata';
        } catch (e) {
            // ie、chrome的安全机制无法修改parent.location.hash，
            // 所以要利用一个中间的cnblogs域下的代理iframe
            var ifrproxy = document.createElement('iframe');
            ifrproxy.style.display = 'none';
            ifrproxy.src = 'http://a.com/cs3.html#somedata'; // 注意该文件在"a.com"域下
            document.body.appendChild(ifrproxy);
        }
    }
/*http://a.com/cs3.html*/
    //因为parent.parent和自身属于同一个域，所以可以改变其location.hash的值
    parent.parent.location.hash = self.location.hash.substring(1);
</code></pre>

问题：

1）数据直接暴露在了url中

2）数据容量和类型都有限

**5、利用iframe和window.name**

原理:

与上面 利用iframe和location.hash 的原理类似，都是由 a.com域下文件的iframe指向 b.com域下的文件，并在b.com域下的文件中指回a.com域下的其他文件，然后由a.com下的两个文件实现跨域

<pre><code class="JavaScript">
/*http://a.com/cs1.html*/
    var state = 0, 
    iframe = document.createElement('iframe'),
    loadfn = function() {
        if (state === 1) {
            var data = iframe.contentWindow.name;    // 读取数据
            alert(data);    //弹出'I was there!'
        } else if (state === 0) {
            state = 1;
            // 设置的代理文件
            iframe.contentWindow.location = "http://a.com/proxy.html";   
        }  
    };
    iframe.src = 'http://b.com/cs2.html';
    if (iframe.attachEvent) {
        iframe.attachEvent('onload', loadfn);
    } else {
        iframe.onload  = loadfn;
    }
    document.body.appendChild(iframe);

/*http://b.com/cs2.html*/
//这里是要传输的数据，大小一般为2M，IE和firefox下可以大至32M左右
// 数据格式可以自定义，如json、字符串
    window.name = 'I was there!';   
</code></pre>

总结起来即：iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。

**6、使用HTML5 postMessage**

HTML5中最酷的新功能之一就是 跨文档消息传输Cross Document Messaging。下一代浏览器都将支持这个功能：Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+ 。 

**otherWindow.postMessage(message, targetOrigin)**<br/>
**otherWindow**: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性；window.open的返回值；通过name或下标从window.frames取到的值。<br/>
**message**: 所要发送的数据，string类型。<br/>
**targetOrigin**: 用于限制otherWindow，“*”表示不作限制,字符串参数，指明目标窗口的源，协议+主机+端口号[+URL]，URL会被忽略，所以可以不写，这个参数是为了安全考虑，postMessage()方法只会将message传递给指定窗口，当然如果愿意也可以建参数设置为"*"，这样可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"。

<pre><code class="JavaScript">
/*http://a.com/index.html*/
// < iframe id="ifr" src="b.com/index.html"></iframe>
    window.onload = function() {
        var ifr = document.getElementById('ifr');
        // 若写成'http://b.com/c/proxy.html'效果一样
        // 若写成'http://c.com'就不会执行postMessage了
        var targetOrigin = 'http://b.com';  
        ifr.contentWindow.postMessage('I was there!', targetOrigin);
    };

/*http://b.com/index.html*/
    //接收消息，监听window的message事件
    window.addEventListener('message', function(event){
        // 通过origin属性判断消息来源地址
        if (event.origin == 'http://a.com') {
            alert(event.data);    // 弹出"I was there!"
            alert(event.source);  // 对a.com、index.html中window对象的引用
                                  // 但由于同源策略，这里event.source不可以访问window对象
        }
    }, false);
</code></pre>

与 document.domain+iframe的设置 不同的是，不受主域相同的限制

**7、web sockets**

web sockets是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用)

web sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。

只有在支持web socket协议的服务器上才能正常工作。

<pre><code class="JavaScript">
    var socket = new WebSockt('ws://www.baidu.com');//http->ws; https->wss
    socket.send('hello WebSockt');
    socket.onmessage = function(event){
        var data = event.data;
    }
</code></pre>



___