<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="/lib/stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="/lib/stylesheets/github-light.css" media="screen">
    <link rel="stylesheet" type="text/css" href="/lib/stylesheets/print.css" media="print">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Gaomin.GitHub.io by gaomin</title>
  </head>
  <body>
    <header>
      <div class="inner">
        <a href="http://gaomin.github.io"><h1>Gaomin.GitHub.io</h1></a>
        <h2>GM blog</h2>
        <a href="https://github.com/gaomin" class="button"><small>Follow me on</small> GitHub</a>
      </div>
    </header>
    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">

    
    <body>
　　　　<h2 id="promise">谈谈promise</h2>
<p>记得去年面试的时候，有面试官问我关于promise的知识点，因为工作中没有涉及到这部分的内容，一直没有关注，最近突然想起来了，正好也有时间，就补一下promise的知识，OK，闲话不多说了，首先，promise是什么</p>

<ol>
  <li>promise是什么</li>
</ol>

<p>鑫旭大神在他的博客中提到，Promise是一种形式，我觉得有一点点抽象，暂且认为promise是一个对象</p>

<ol>
  <li>为什么需要promise</li>
</ol>

<p>刚听说promise的时候，我也去稍微理解了一下，大部分看到的资料都是关于promise的语法，于是十分困惑，究竟为什么要用promise呢？知道后来开发中遇到了真实的情景，才明白promise存在的价值，OK，慢慢说。</p>

<p>举个例子，首先，大家肯定都用过了Ajax，我们回一下Ajax是通过什么方式处理返回数据的呢，Callback！</p>

<pre>
    <code>
    jQuery.ajax({
        type:'get',
        url:'***',
        success:function(res){
            ...
        },
        error:function(){
            ....
        }
    });
    </code>
</pre>

<p>上面这段代码是一个Ajax的例子，我们在平时的开发中已经用的很熟了，有什么问题吗? ok,我们来试想一下，如果我们的逻辑非常复杂，返回数据后，有要发送请求，代码如下：</p>

<pre>
    <code>jQuery.ajax({
        type:'get',
        url:'***',
        success:function(res){
            jQuery.ajax({
                type:'get',
                url:'***',
                success:function(res){
                    jQuery.ajax({
                        type:'get',
                        url:'***',
                        success:function(res){
                           jQuery.ajax({
                                type:'get',
                                url:'***',
                                success:function(res){
                                    ...
                                },
                                error:function(){
                                    ....
                                }
                            });
                        },
                        error:function(){
                            ....
                        }
                    });
                },
                error:function(){
                    ....
                }
            });
        },
        error:function(){
            ....
        }
    });
    </code>
</pre>

<p>我相信这么复杂的情况，开发中遇到的还是比较少的，我曾经做充值业务的时候遇到了一次，上面的代码还是用省略号简化过的，都已经感觉不能看了，更别提真实的代码了。</p>

<p>这种情况有个说法，‘回调金字塔’，也有人叫’回调地狱‘。之所以叫做‘地狱’，为啥呢，想也知道，根本没办法维护嘛，想想一下，两个月后去修改这段代码，或者别的人去交接， oh my god! 当然，有经验的前端可以通过定义多个function等方法改善这种情况，但是这种做法也不是很优美，在各种函数中间跳来跳去，增加了理解的难度，那么如何友好的解决这个问题呢？promise嘛！</p>

<ol>
  <li>promise怎么用</li>
</ol>

<p>1) 首先，看看原生promise的用法：</p>

<p>原生的promise是以构造函数存在的，我们看看各个浏览器里的promise实现(IE没测)</p>

<p>chrome:</p>

<p><img src="/lib/blog-imgs/20160108-promise--chrome.jpg" alt="promise" /></p>

<p>safari:</p>

<p><img src="/lib/blog-imgs/20160108-promise--safari.jpg" alt="promise" /></p>

<p>firefox:</p>

<p><img src="/lib/blog-imgs/20160108-promise--firefox.jpg" alt="promise" /></p>

<p>虽然不完全相同，但是都包括了 then 和 catch 方法</p>

<pre><code>var promise = new Promise(function(resolve, reject){
    // ... some code
    if (/* 异步操作成功 */){
        resolve(value);
    } else {
        reject(error);
    }
});

promise.then(function(value) {
  // success
}, function(value) {
  // failure  
});
</code></pre>
<p>首先创建了一个promise对象，<strong>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject</strong>。它们是两个函数，由JavaScript引擎提供，不用自己部署。</p>

<p>resolve函数的作用是，在异步操作成功时调用，将异步操作的结果，作为参数传递出去；reject函数的作用是，在异步操作失败时调用，将异步操作报出的错误，作为参数传递出去。</p>

<p><strong>then方法接收两个回调函数作为参数，第一个是成功的回调，第二个是失败的回调(可选)</strong></p>

<pre><code>var promise = new Promise(function(resolve, reject){
    // ...
});
promise.then(function(json) {
  // ...
}).then(function(post) {
  // ...
});
</code></pre>

<p><strong>链式的then</strong>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。</p>

<p><strong>catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</strong></p>
<pre><code>promise.then(function(posts) {
  // ...
}).catch(function(error) {
  // 处理前一个回调函数运行时发生的错误
  console.log('发生错误！', error);
});
</code></pre>

<p>写着写着就这么多了，看着好累，分成两节吧，下一节看看jQuery中的promise用法，以及内部实现，最后给个实例hapyy下吧（拿去跑跑呦）：</p>
<pre><code>var money = 4;
var buy = function(goods){
  return new Promise(function(resolve, reject){
    if (money &gt; 0){
      console.log('恭喜，您成功购买了'+ goods);
      money--;
      resolve();
      return
    }
    console.log('亲，余额不足了呦~');
  });
};

buy('书').then(buy('衣服'))
        .then(buy('食品'))
        .then(buy('房子'))
        .then(buy('买买买'));
</code></pre>

<hr />


        <!-- UY BEGIN -->
        <div id="uyan_frame"></div>
        <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2079507"></script>
        <!-- UY END -->
    </body>
</section>

        <aside id="sidebar">
    <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
</aside>
      </div>
    </div>

  </body>
</html>
　
